<DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - buffergeometry - indexed</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			a {
				color: #08f;
			}
		</style>
		<script src="bsjs/perlin.js" ></script>
		<script src="bsjs/worley.js" ></script>
	</head>
	<body>

		<div id="container"></div>


 <script type="module">
 class bsPattern
 {
   w = 10;
   h = 10;
   constructor(xw,xh)
   {
      this.w=xw;
      this.h=xh;
   }

   array2D(numrows, numcols, initial)
   {
     var arr = [];
   	for(var i = 0; i < numrows; ++i)
   	 {
   	   var columns = [];
   	   for (var j = 0; j < numcols; ++j)
   		 {
   	     columns[j] = initial;
   	   }
   	   arr[i] = columns;
   	 }
   	 return arr;
   }
     //=================================
     //White noise function
     noise()
     {
       var res = this.array2D(this.w,this.h,0);
       var i = 0;
       for(var x = 0; x<this.w; x++)
       {
         for(var y = 0; y<this.h; y++)
         {
           res[x][y]=Math.random();
         }
       }
       return(res);
     }
     //=================================
     //perlin noise function
     perlin(scale)
     {
       var res = this.array2D(this.w,this.h,0);
       var seed = Math.random();
       var i = 0;
       for(var x = 0; x<this.w; x++)
       {
         for(var y = 0; y<this.h; y++)
         {
           res[x][y]=PerlinNoise.noise((x/this.w)*scale,(y/this.h)*scale,seed);
         }
       }
       return(res);
     }
     //=================================
     //Worley noise function
     worley(n)
     {
       var xnoise = new WorleyNoise({ numPoints: n, dim: 2 });
       var buf = xnoise.renderImage(this.w, { normalize: true });
       var res = this.array2D(this.w,this.h);
       var i =0;
       for(var x=0; x<this.w; x++)
       {
         for(var y=0; y<this.h; y++)
         {
           res[x][y]=buf[i];
           i++;
         }
       }
       return(res);
     }

     add(map1,map2,force1,force2)
     {
       var res = this.array2D(this.w,this.h,0);
       var force_sum=force1+force2;
       var i =0;
       for(var x=0; x<this.w; x++)
       {
         for(var y=0; y<this.h; y++)
         {

           res[x][y]=((map1[x][y]*force1)+(map2[x][y]*force2))/force_sum;
           i++;
         }
       }
       return(res);
     }

     lighten(map1,map2)
     {
       let res = this.array2D(this.w,this.h,0);
       var i =0;
       for(var x=0; x<this.w; x++)
       {
         for(var y=0; y<this.h; y++)
         {
           if(map1[x][y] > map2[x][y])
           {
             res[x][y]=map1[x][y];
           }
           else
           {
             res[x][y]=map2[x][y];
           }
           i++;
         }
       }
       return(res);
     }

     neg(map)
     {
       var res = this.array2D(this.w,this.h,0);
       var i =0;
       for(var x=0; x<this.w; x++)
       {
         for(var y=0; y<this.h; y++)
         {
           res[x][y]=1.0-map[x][y];
           i++;
         }
       }
       return(res);
     }



 }

 class blob
 {
 	mesh;
 	mesh2;
 	geometry;
 	material;
 	rude;
 	scaleX;
 	scaleY;
 	scaleZ;
 	segments;

 	constructor(mat)
 	{
 		this.material=mat;
 		this.rude=2.5;
 		this.scaleX=1.0;
 		this.scaleY=1.0;
 		this.scaleZ=1.0;
 		this.segments=4;
 	}

 	make()
 	{
 		this.geometry= new THREE.SphereGeometry(1, this.segments, this.segments);
 		for (var i = 0; i < this.geometry.vertices.length; i++)
 		{
 			var p = this.geometry.vertices[i];
 			p.x=(p.x+(Math.random()/this.rude))*this.scaleX;
 			p.y=(p.y+(Math.random()/this.rude))*this.scaleY;
 			p.z=p.z*this.scaleZ;
 			//p.normalize().multiplyScalar(Math.random()/4.0);
 		}
 		this.geometry.computeVertexNormals();
 		this.geometry.normalsNeedUpdate = true;
 		this.geometry.verticesNeedUpdate = true;
 		this.mesh = new THREE.Mesh(this.geometry, this.material);
 	}

 	getMesh()
 	{
 		return(this.mesh);
 	}

 	moveMesh(x,y,z)
 	{
 		var position = new THREE.Vector3();
 		this.mesh.position.x = x;
 		this.mesh.position.y = y;
 		this.mesh.position.z = z;
 	}

 	rotate(x,y,z)
 	{
 		this.mesh.rotateX(x);
 		this.mesh.rotateY(y);
 		this.mesh.rotateZ(z);
 	}
 }

class bsBuilding
{
	mesh;
	geometry;
	material;

	constructor(x,y,z)
	{
     this.geometry = new THREE.BoxBufferGeometry( x, y, z );
		 this.material = new THREE.MeshPhongMaterial( { color: 0x00ccff, wireframe: false } );
		 this.mesh = new THREE.Mesh( this.geometry, this.material );
	}

	getMesh()
	{
		return(this.mesh);
	}

	moveMesh(x,y,z)
	{
		var position = new THREE.Vector3();
	  this.mesh.position.x = x;
		this.mesh.position.y = y;
		this.mesh.position.z = z;
	}


}



		import * as THREE from '../build/three.module.js';
		import { TrackballControls } from './jsm/controls/TrackballControls.js';

		import { EffectComposer } from './jsm/postprocessing/EffectComposer.js';
					import { RenderPass } from './jsm/postprocessing/RenderPass.js';
					import { SAOPass } from './jsm/postprocessing/SAOPass.js';


			var camera, scene, renderer, controls, light;
			var mesh;
      var composer, renderPass, saoPass;

				var geometry = new THREE.BufferGeometry();
				var vertices;
				var segments = 70;
				var bld = [];


        /*for(var i=0; i<1000; i++)
				{
				  //bld[i] = new bsBuilding(Math.random(),Math.random(),Math.random());
					bld[i] = new blob(new THREE.MeshStandardMaterial( { color: new THREE.Color("hsl("+(Math.floor(Math.random()*30)+20)+","
						+(Math.floor(Math.random()*100)+50)+"%,50%)"), roughness:1.0, flatShading:true, wireframe:false }));
						bld[i].segments=Math.floor(Math.random()*7)+4;
	          var sc = (Math.random()/4.0)*(Math.random()*5.0);

						bld[i].scaleY = sc;
	          bld[i].scaleZ = sc;
	          bld[i].scaleX = sc;

						bld[i].make();
				}*/





			init();
			animate();
			function init() {
				//
				camera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 1, 3500 );
				camera.position.z = 64;
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x050505 );
				//
				var light1 = new THREE.HemisphereLight();
				//scene.add( light1 );

				scene.add( new THREE.AmbientLight( 0x222222 ) ); //some ambient to see int the dark
				light = new THREE.PointLight( 0xffffff );        //a spotlight added to the camera
				light.position.copy( camera.position );
				scene.add( light );

				//



        geometry = new THREE.PlaneBufferGeometry(50,50,segments,segments);




				// load a texture, set wrap mode to repeat
				var texture = new THREE.TextureLoader().load( "res/sand.jpg");
				texture.wrapS = THREE.RepeatWrapping;
				texture.wrapT = THREE.RepeatWrapping;
				texture.repeat.set( 14, 14);


				var material = new THREE.MeshPhongMaterial( {
						color: 0xffcc66,
						//new THREE.Color("hsl("+(Math.floor(Math.random()*50)+20)+","
						//+Math.floor(Math.random()*100)+"%,50%)"),
						roughness:0.96,
						flatShading:false,
						wireframe:false,
						map:texture,
						side: THREE.DoubleSide
					});
					material.map=texture;
					//console.log(material);
					mesh = new THREE.Mesh( geometry, material );
	 				scene.add( mesh );








				/*var material = new THREE.MeshStandardMaterial( {
					side: THREE.DoubleSide,
					vertexColors: THREE.VertexColors,
					flatShading:false,
					color: 0xcfe8666,
					wireframe : false,
					/metalness : 0,
					roughness: 1.0,
					map:texture

				} );*/


				//
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				// controls
        controls = new TrackballControls( camera, renderer.domElement );
        controls.zoom=0.05;
        controls.rotateSpeed = 2.0;
        controls.zoomSpeed = 0.2;
        controls.panSpeed = 0.8;
        controls.staticMoving = false;
        controls.dynamicDampingFactor = 0.1;
        controls.keys = [ 65, 83, 68 ];

				//postprocessing
				composer = new EffectComposer( renderer );
				renderPass = new RenderPass( scene, camera );
				composer.addPass( renderPass );
				saoPass = new SAOPass( scene, camera, false, true );
				composer.addPass( saoPass );
				saoPass.params.saoIntensity=0.00035;
        saoPass.params.saoBlurRadius=5;

//add object



				//
				window.addEventListener( 'resize', onWindowResize, false );

       realtime();

			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			//
			function animate() {
				requestAnimationFrame( animate );
				render();
        controls.update();
				light.position.copy(camera.position);
				composer.render();

			}
			function render() {
				var time = Date.now() * 0.001;
				renderer.render( scene, camera );
			}



	function array2D(numrows, numcols, initial)
	{
	  var arr = [];
		 for(var i = 0; i < numrows; ++i)
		 {
		   var columns = [];
		   for (var j = 0; j < numcols; ++j)
			 {
		     columns[j] = initial;
		   }
		   arr[i] = columns;
		 }
		 return arr;
	}

function coords(x,y,vertices)
{
    var adress =((y*(segments+1))+x)*3;
    return({x:vertices[adress],y:vertices[adress+1],z:vertices[adress+2]});
}

function realtime()
{

  //constructing an array of perl noise
	var noise = array2D(segments+1,segments+1,0);
	var noisesize = (Math.random()*10)+4 ;
	for(var x = 0; x<segments+1; x++)
	{
		for(var y = 0; y<segments+1; y++)
		{
			noise[x][y]=PerlinNoise.noise(noisesize*(x/segments),noisesize*(y/segments),0.8);
		}
	}




	var noise1 = array2D(segments+1,segments+1,0);
	var noisesize = (Math.random()*8);

  var p =  new bsPattern(segments+1,segments+1);
	//noise = p.lighten(p.neg(p.worley((Math.random()*300)+10)),p.worley((Math.random()*10)+10));
	//noise = p.perlin(10);
	//noise = p.noise();
  var noise = p.worley(500);
	var noise1=p.perlin(2); //p.add(p.perlin(1),p.perlin(100),1,4);
	var noise3 = p.worley((Math.random()*100)+10);



	var vertices = geometry.getAttribute('position').array;
	for(var i = -1; i < vertices.length; i=i+3)
	{
		if(i>0)
		{
			vertices[i]=
			//noise[Math.floor((i/3) / (segments+1))][ Math.floor((i/3)) % (segments+1)]*2;
			(
				((noise[Math.floor((i/3) / (segments+1))][ Math.floor((i/3)) % (segments+1)])*2)+
				((noise1[Math.floor((i/3) / (segments+1))][ Math.floor((i/3)) % (segments+1)])*12)
			)

		}

		//if(i==1 ) bld[0].moveMesh(vertices[i-2],vertices[i-1],vertices[i]);
    //if(i==8789) bld[1].moveMesh(vertices[i-2],vertices[i-1],vertices[i]);
    //if(i==24101) bld[2].moveMesh(vertices[i-2],vertices[i-1],vertices[i]);


  }
	mesh.geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
	mesh.geometry.computeFaceNormals();
	mesh.geometry.computeVertexNormals();
	mesh.geometry.normalsNeedUpdate = true;
  mesh.geometry.verticesNeedUpdate = true;


	var i = 0;
  for(x=0; x<segments; x++)
  {
    for(y=0; y<segments; y++)
    {
      if(noise3[x][y]>0.2)
      {
				var sc=(noise3[x][y]-0.2)*3.0;
				if(Math.random()>0.01)
				{
          var pos = coords(x,y,vertices);
				  bld[i] = new blob(new THREE.MeshPhongMaterial( { color: new THREE.Color("hsl("+(Math.floor(noise3[x][y]*30)+20)+","
					+(Math.floor(Math.random()*100)+50)+"%,50%)"), roughness:1.0, flatShading:true, wireframe:false }));
					  bld[i].segments=Math.floor(Math.random()*7)+4;
					  //var sc = (Math.random()/4.0)*(Math.random()*5.0);


					  bld[i].scaleY = sc;
					  bld[i].scaleZ = sc;
					  bld[i].scaleX = sc;

					  bld[i].make();
            bld[i].moveMesh(pos.x,pos.y,pos.z);
					  scene.add(bld[i].getMesh());
          i++;
				}
      }
    }

  }




}

		</script>
<a href="javascript:realtime()" style="display:block; position:absolute; top:20px; right:20px; z-index:1000; width:40px; height:40px; border-radius:50%; background:rgba(255,255,255,0.8)"></a>
	</body>
